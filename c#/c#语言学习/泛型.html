<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.3/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"泛型的优势和特点和优化","children":[{"type":"list_item","depth":2,"payload":{"lines":[1,2]},"content":"特点","children":[{"type":"list_item","depth":3,"payload":{"lines":[2,3]},"content":"如果不写泛型,那么在参数上面你只能去写Object,这样就会频繁的装箱和拆箱,造成几倍的性能浪费,写了泛型就可以利用泛型来指定类型,而不去考虑参数的转换."}]},{"type":"list_item","depth":2,"payload":{"lines":[3,4]},"content":"代码编译的优化","children":[{"type":"list_item","depth":3,"payload":{"lines":[4,5]},"content":"当CLR文件编译一个List&lt; String&gt;的时候,他在.dll文件(大致意思)上就会生成一个,下次在遇见就不会在编译了"}]},{"type":"list_item","depth":2,"payload":{"lines":[5,6]},"content":"匹配的过程","children":[{"type":"list_item","depth":3,"payload":{"lines":[6,7]},"content":"c#首先会继续类型的匹配,然后才是泛型的匹配"},{"type":"list_item","depth":3,"payload":{"lines":[7,8]},"content":"这样就意味着如果你有非泛型,那么会优先调用,然后才是你的泛型"}]}]},{"type":"heading","depth":1,"payload":{"lines":[8,9]},"content":"泛型主要集中的区域"},{"type":"heading","depth":1,"payload":{"lines":[12,13]},"content":"泛型使用技巧","children":[{"type":"heading","depth":2,"payload":{"lines":[13,14]},"content":"使用技巧一","children":[{"type":"list_item","depth":3,"payload":{"lines":[14,15]},"content":"链表中书写泛型(如果我们直接采用下面的写法存在一些问题)","children":[{"type":"bullet_list","depth":4,"payload":{"lines":[15,18]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[15,16]},"content":"因为我们是写的泛型 所以我们希望链表的各个节点都是不同类型"},{"type":"list_item","depth":5,"payload":{"lines":[16,17]},"content":"那么头节点是 Node&lt; Text&gt; 下一个节点是 Node&lt; Int&gt; 那么图片中第二参数他们的<T>是不同的 出现了转换 这个是很麻烦的"},{"type":"list_item","depth":5,"payload":{"lines":[17,18]},"content":""}]},{"type":"bullet_list","depth":4,"payload":{"lines":[19,22]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[19,20]},"content":"正确做法 :","children":[{"type":"list_item","depth":6,"payload":{"lines":[20,22]},"content":"先写一个基类,在基类中定义Next Node 利用多态来解决这个问题<br>\n<img src=\"2022-10-15-11-32-00.png\" alt=\"\">"}]}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[22,23]},"content":"使用技巧二(泛型的同一性 书)","children":[{"type":"bullet_list","depth":3,"payload":{"lines":[23,25]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[23,24]},"content":"简化书写,同时c#提供手段保证,这两个类型是一致的"},{"type":"list_item","depth":4,"payload":{"lines":[24,25]},"content":"在文件开头书写"}]},{"type":"blockquote","depth":3,"payload":{"lines":[25,27]},"content":"","children":[{"type":"paragraph","depth":4,"payload":{"lines":[25,27]},"content":"using DateTimeList =System.collections.Generic.List&lt; System.DateTime&gt;;<br>\n使用typeof时候他们之间是等价的."}]}]},{"type":"heading","depth":2,"payload":{"lines":[28,29]},"content":"使用技巧三(错误用法)","children":[{"type":"list_item","depth":3,"payload":{"lines":[29,30]},"content":"在泛型内部使用显示转换是明显的错误 T a =(string) b"},{"type":"list_item","depth":3,"payload":{"lines":[30,31]},"content":"你直接将T and =null 也是错误的 因为当T是值类型时,他不存在指向null引用类型, 但是你对他使用 ==null 和!=null是合法的,因为值类型时,不管值是多少都会返回false"},{"type":"list_item","depth":3,"payload":{"lines":[31,32]},"content":"还是前面提到的 给泛型随便使用操作符是违法"}]}]},{"type":"heading","depth":1,"payload":{"lines":[33,34]},"content":"泛型的三种约束十分重要","children":[{"type":"heading","depth":2,"payload":{"lines":[34,35]},"content":"主要约束(主要是针对引用类型)","children":[{"type":"list_item","depth":3,"payload":{"lines":[35,37]},"content":"你不能使用where 约束下面这些特殊的引用类型<br>\n<img src=\"2022-10-15-20-34-52.png\" alt=\"\">"},{"type":"list_item","depth":3,"payload":{"lines":[37,38]},"content":"class 和struct 两个特殊的主要约束","children":[{"type":"blockquote","depth":4,"payload":{"lines":[38,39]},"content":"","children":[{"type":"paragraph","depth":5,"payload":{"lines":[38,39]},"content":"internal sealed class ParmaryConstranitOfClass&lt; T&gt; where T:class  或者 struct 前者代表你T是一个引用类型 而 struct是代表值类型"}]},{"type":"bullet_list","depth":4,"payload":{"lines":[39,41]},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[39,40]},"content":"class 和struct 的区分有很多的作用,class 说明你继承了Object 岂不是 那几种方法就可在泛型中书写了."}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[41,42]},"content":"次要约束(这个是让你的T 必须实现一部分接口)","children":[{"type":"blockquote","depth":3,"payload":{"lines":[42,43]},"content":"","children":[{"type":"paragraph","depth":4,"payload":{"lines":[42,43]},"content":"private static List&lt; TBase&gt; ConvertList&lt; T,Tbase&gt; (Ilist&lt; T&gt; list )where T:TBase;"}]},{"type":"bullet_list","depth":3,"payload":{"lines":[43,45]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[43,44]},"content":"这种写法好处是 两个参数发生了联系,至少你能确定,T和TBase 有了一定的关系,而不是毫无目的"}]}]},{"type":"heading","depth":2,"payload":{"lines":[45,46]},"content":"构造器约束(让你的引用类型 必须有一个无参数的构造)","children":[{"type":"list_item","depth":3,"payload":{"lines":[46,47]},"content":"配合struct使用时非法的,c#中值类型他会默认提供一个初始值,所以你写struct就是多余的"},{"type":"list_item","depth":3,"payload":{"lines":[47,48]},"content":"internal sealde class ParmaryConstranitOfClass&lt; T&gt; Where T:new(){};"}]}]},{"type":"heading","depth":1,"payload":{"lines":[50,51]},"content":"泛型有很多的应用地方","children":[{"type":"heading","depth":2,"payload":{"lines":[51,52]},"content":"泛型类","children":[{"type":"list_item","depth":3,"payload":{"lines":[52,53]},"content":"因为你不知道实例化的类的内部构造 such as: 一个Type you don`t kown 他们之间是否可以相乘"},{"type":"list_item","depth":3,"payload":{"lines":[53,55]},"content":"这也导致你不能在泛型类中轻易使用各种运算符(如下图,即使简单的加法你实现也有问题)<br>\n<img src=\"2022-09-25-00-05-18.png\" alt=\"\">"},{"type":"list_item","depth":3,"payload":{"lines":[55,57]},"content":"Object 类实现了 ToString Equals GetType 所以这三个你可以随意使用<br>\n<img src=\"2022-09-24-23-46-26.png\" alt=\"\">"}]},{"type":"heading","depth":2,"payload":{"lines":[59,60]},"content":"泛型函数","children":[{"type":"list_item","depth":3,"payload":{"lines":[60,61]},"content":"没有什么可以讲的 ,但是他的where 依旧比较硬核跟 泛型类的约束相似."},{"type":"list_item","depth":3,"payload":{"lines":[61,63]},"content":"好像string根本就不算类和int相似.<br>\n<img src=\"2022-09-24-23-50-53.png\" alt=\"\">"}]},{"type":"heading","depth":2,"payload":{"lines":[66,67]},"content":"泛型委托","children":[{"type":"bullet_list","depth":3,"payload":{"lines":[67,68]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[67,68]},"content":"我认为前面的都没啥新奇的,这个委托需要写一写"}]},{"type":"fence","depth":3,"content":"<pre class=\"language-C#\"><code class=\"language-C#\">delegate T3 Mydelegat&lt;T1, T2, T3&gt;(T1 t1, T2 t2);\nMydelegat&lt;string, string, string&gt; mydelegat_1 = new Mydelegat&lt;string, string, string&gt;(Person.xiangchu);               //的确非常复杂.\n</code></pre>\n"}]},{"type":"heading","depth":2,"payload":{"lines":[74,75]},"content":"泛型接口","children":[{"type":"list_item","depth":3,"payload":{"lines":[75,77]},"content":"在泛型上面拓展泛型这样的确不太理想过于复杂(当然你也可以但是要保证接口泛型参数一致)<br>\n<img src=\"2022-09-25-00-20-26.png\" alt=\"\">"},{"type":"list_item","depth":3,"payload":{"lines":[77,79]},"content":"所有我认为非泛型的拓展接口更加合适<br>\n<img src=\"2022-09-25-00-19-41.png\" alt=\"\">"}]},{"type":"heading","depth":2,"payload":{"lines":[83,84]},"content":"委托的协变和逆变(不规范书写将会导致编译通不过)","children":[{"type":"bullet_list","depth":3,"payload":{"lines":[84,97]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[84,85]},"content":"委托的协变(如果返回值有继承关系,可以利用)","children":[{"type":"list_item","depth":5,"payload":{"lines":[85,86]},"content":"解决一个老生常谈的问题,我们两实例化的形参有继承关系,而我们的实例化的对象却没有继承关系"},{"type":"list_item","depth":5,"payload":{"lines":[86,87]},"content":"这个只适用于改变返回类型","children":[{"type":"paragraph","depth":6,"payload":{"lines":[87,90]},"content":"delegate T Factory&lt;(out) T&gt;  out协变 改变返回类型T<br>\n+ &gt;Factory&lt;_Dog&gt; Dog_1= new ......   //Anmail 是Dog的父类<br>\n+ &gt;Factory&lt;_Anmail&gt; Anmail =Dog_1;   //实现了这种委托的转变"}]}]},{"type":"list_item","depth":4,"payload":{"lines":[90,91]},"content":"委托的逆变技术(参数的继承,扩展到整个委托的继承关系)","children":[{"type":"list_item","depth":5,"payload":{"lines":[91,92]},"content":"一般我们有这种需求"},{"type":"list_item","depth":5,"payload":{"lines":[92,93]},"content":"","children":[{"type":"paragraph","depth":6,"payload":{"lines":[92,93]},"content":"delegate void Factory&lt;(i)n T&gt;(T a);"}]},{"type":"list_item","depth":5,"payload":{"lines":[93,94]},"content":"","children":[{"type":"paragraph","depth":6,"payload":{"lines":[93,94]},"content":"Factory&lt;_Anmail&gt; Anmail =new ......"}]},{"type":"list_item","depth":5,"payload":{"lines":[94,95]},"content":"","children":[{"type":"paragraph","depth":6,"payload":{"lines":[94,95]},"content":"Factory&lt;_Dog&gt; Dog_1= Anmail   // 显然这种操作不合理"}]},{"type":"list_item","depth":5,"payload":{"lines":[95,96]},"content":"","children":[{"type":"paragraph","depth":6,"payload":{"lines":[95,96]},"content":"Dog_1(new Dog());            //但是 参数 new Dog() 转成anmail似乎就合理了"}]},{"type":"list_item","depth":5,"payload":{"lines":[96,97]},"content":"所以in给第三行的代码提供了一个合法性,让你先通过编译"}]}]},{"type":"blockquote","depth":3,"payload":{"lines":[101,103]},"content":"","children":[{"type":"paragraph","depth":4,"payload":{"lines":[101,103]},"content":"public delegate TResult Func&lt;(in) T, out TResult&gt;(T arg);<br>\nFunc&lt;(Object, ArgumentException&gt; F1 = null;"}]},{"type":"blockquote","depth":3,"payload":{"lines":[104,105]},"content":"","children":[{"type":"paragraph","depth":4,"payload":{"lines":[104,105]},"content":"Func&lt;(string, Exception&gt; F2 = F1;  //"}]},{"type":"bullet_list","depth":3,"payload":{"lines":[105,111]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[105,106]},"content":"程序入口:","children":[{"type":"list_item","depth":5,"payload":{"lines":[106,107]},"content":"每个概念需要从他的程序入口理解, 只有F2调用时才能用到我们前面的协变等, F2调用那么首先是F2接受参数,因为调用了F1 所以是String 转Object 没有问题,"}]},{"type":"list_item","depth":4,"payload":{"lines":[107,108]},"content":"然后进入程序内部:","children":[{"type":"list_item","depth":5,"payload":{"lines":[108,109]},"content":"F2指向F1,而F1在程序内部就是ArgumentException,这里你会好奇,在程序开头为什么不会发生Exception,ArgumentException这个违法行为,这是因为Exception他是协变,是返回值,不是输入值,所以开头没有这种情况,"}]},{"type":"list_item","depth":4,"payload":{"lines":[109,110]},"content":"程序末尾,因为最终是F2返回,所以内部F1 ArgumentException会变成Exception 转换合法,这个就是协变和逆变的终极合理性"}]}]},{"type":"heading","depth":2,"payload":{"lines":[111,112]},"content":"接口的协变和逆变","children":[{"type":"bullet_list","depth":3,"payload":{"lines":[112,113]},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[112,113]},"content":"主要用于参数的类型转换 ,其他的想不到了别的用途"}]},{"type":"fence","depth":3,"content":"<pre class=\"language-C#\"><code class=\"language-C#\"> class Animal { public string Name; }\n    class Dog : Animal { }\n    \n    \n    interface ImyIf&lt;out T&gt;\n    {\n        T GetFirst();\n\n    }\n    class SimpleReturn&lt;T&gt; : ImyIf&lt;T&gt;\n    {\n\n        public T[] items = new T[2];\n        public T GetFirst() { return items[0]; }\n\n    }\n    class Program\n    {\n        static void DoSomething(ImyIf&lt;Animal&gt; returner)\n        {\n            Console.WriteLine(returner.GetFirst().Name);\n        }\n\n        static void Main()\n        {\n            SimpleReturn&lt;Dog&gt; dogReturner = new SimpleReturn&lt;Dog&gt;();\n            dogReturner.items[0] = new Dog()\n            {\n                Name = &quot;Avolea&quot;\n            };\n\n            ImyIf&lt;Dog&gt; animaRetruner = dogReturner;   //正确\n            ImyIf&lt;Animal&gt; animaRetruner = dogReturner;   //正确\n            SimpleReturn&lt;Animal&gt; animaRetruner = dogReturner;   //报错\n            // 这里虽然没有任何意义 但是他显示的写了出来\n            // 第一种和第二种正确 他们的使用含义清楚\n            // 第三种失败的原因在于 类他无法使用out,所以这种转变失败\n            // ImyIf&lt;Dog&gt; 转ImyIf&lt;Animal&gt; 失败,是因为Imyif&lt;Dog&gt;的初始化就不成功,new 接口不太现实 \n            DoSomething(dogReturner);\n        }\n\n\n    }\n\n</code></pre>\n"}]}]}],"payload":{}},{})</script>
</body>
</html>
