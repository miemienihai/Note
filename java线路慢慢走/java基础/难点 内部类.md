## 四种内部类
### 局部内部类
+ 通常定义在类中的函数中的和代码块(代码块本质是函数)
+ 内部类他是没有修饰符号的,也就是没有public这样的符号.但是可以使用final修饰
+ 作用域 :仅仅在他定义的方法中,和代码块中,这里我们得区分一下,你内部类本质上还是一个局部变量,所以定义在方法中的内部类,你在代码块中依然看不到,因为你已经调到别的函数中了
+ 内部类他是可以看到外部类的变量和方法的,别人看不到他,你就把它当做一个变量来理解

+ 如果内部类变量名叫m1 外部类定义了一个变量m1这个时候你想在内部类中定义外部类的变量m1,你得写成,外部类名.this.m1 这句话你这样理解,你直接调用this.m1,这个是内部类的m1,外部类的this再调用m1就可以了,同时你不用考虑这个this是否存在,只有外部类被创建了才会有内部类.

### 匿名内部类(!!!!!!精华)
+ 我们定义好了接口,经常需要扩展接口生成一个类,不过这个类有的时候只使用一次,如果单独书写成一个类会非常浪费,
+ Fish 接口
```java
interface Fish {
    public static final String name = "一条小鱼";

    default String CallHisName() {

        return Fish.name;
    }

}
```
+ 我们想要生成一条长了翅膀的小鱼
```java
class Feiyu implements Fish {
    private String name1 = "长了翅膀";

    @Override
    public String CallHisName() {
        return Fish.name + name1;
    }
}

```
+ 然后我们再在main 函数中 将它打印出来,这样是不是非常麻烦
+ Fish fish = new Feiyu();
        System.out.println(fish.CallHisName());

+ 然而我们可以一次到位
```java
Fish fish2 = new Fish() {
            private String name1 = "长了翅膀";

            @Override
            public String CallHisName() {
                return Fish.name + name1;
            }
        };
        System.out.println(fish2.CallHisName());
```
### 上述代码的详细介绍
+ new  意味着我们创建了一个对象,所以匿名类往往伴随着创建一个对象,
+ Fish() 接口(或者类) 意味着我们依照接口和对象重新创建了一个类,所以这个新创建的类就叫做匿名类,同时我们是创建的接口或父类的子类,这样我们大大降低了前面的麻烦, 然后fish2利用多态指向了我们这个匿名类, 这样我们就不要知道这个类名叫什么.
+ 这个没有名字的类同样是一个内部类,也就意味着他是一个局部变量,他可以访问外部类的变量,别人访问不到他,这些特性和内部类一样


## 匿名类最适用的技巧
+ 把匿名类当做实参传入,利用形参接口实现动态绑定
```java
public class LocalInnerClass {
    public static void main(String[] args) {
        Feiyu feiyu = new Feiyu();
        feiyu.Fei(new Fish() {//动态绑定
            @Override
            public void CallHisName() {
                System.out.println("一条小鱼长了翅膀");
            }
        });

    }
}


interface Fish {
    default void CallHisName() {
        System.out.println("一条小鱼");
    }

}


class Feiyu {
    public void Fei(Fish fish) {  //形参接口 
        fish.CallHisName();

    }

}


```



## 成员内部类
+ 并不是定义在方法中的类,他和变量定义在同一个作用域下,
+ 所以他可以被外部类看见,同时的作用域就是外部类了.
+ 如何在外部(main)访问内部类OuterClass.innerClass in= OuterClass.new innerClass(); OuterClass 外部类,innerClass 内部类
+ 因为这个类他处于外部类成员位置上,所以他可以当做变量,使用标识符 public等
+ 外部类和内部类变量重名,如何在内部类使用外部类的变量, 外部类.this.变量名;



## 静态成员内部类
+ 因为他是静态的所以作用域在最外面一层
+ 他不能直接访问外部类的非静态变量,因为他们不是在同一个作用域,编译原理,用了一个哈希表来充当作用域,既然静态成员类和非静态变量都不在同一个作用域,静态成员类就不能直接访问非静态变量.
+ 外部类要访问静态内部类 要创建对象再次访问
+ 外部其他类 访问静态内部类
+ Outer10.Inner10 inner10 =new Outer10.Inner10();