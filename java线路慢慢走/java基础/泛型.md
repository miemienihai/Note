## 默认支持泛型有上转型
+ ArrayList<Interger> 转为List<Interger>
+ 但是我们认为ArrayList<Interger> 和ArrayList<number> 不是同一类型,所以模板参数类型不同时,他是不支持转型的.

```java
public class ArrayList<T>{
private T[] array;


public T get(int index){

}
}
```
## 如果泛型得不到实例化时,类型默认为Object
### 接口泛型的应用(!!!非常使用的技巧 )
+ Arrays.sort()函数 ,如果你想要在自定义类中使用它,必须实现Compable这个模板接口
+ class Person implements Comparable<Person>
+ 如果你不实现 在Comparable模板中就没有Comparable<Person>这个特例化,所以你调用sort时候,Person 无法转换成Comparable特例化,就会报错.
+ Person继承自模板Comparable<Person>,自然可以完成转换,同时调用Person中的相关函数

### 静态方法的泛型
+ 类中出现泛型,这个时候static后面不允许添加模板T标识,因为static和类不是在一个作用域中,类的实例化跟静态方法没有关系
+ 如果你也想static存在模板,必须写用其他标识来标识static,以此代表静态模板跟类模板没关系
+ Class<T,K> T用在类中, K留给静态方法
+ public static <K> Pair<K> creat(K first,K last)

### java泛型技术使用的擦拭法
+ 原理: 首先编译器把所有的泛型当成Object处理,然后需要转型时在转型,这个就是擦拭来源
+ 编译器默认把泛型ArrrayList<Integer>一律当成Object处理,所以变成了ArrayList<Object>(后面部分课省略)
+ 编译器根据<T>实现安全的强制转型(需要装换的时候自动装换)

### 擦拭法的局限
+ 同一转变成Object 所以<T>  不能是基础类型
+ getClass() 得到的都是Object类型,所以无法取得带泛型的Class
+ 无法判断带泛型的类型 p instanceof Pair<String>翻译成 Pair.class
+ 不能实例化T,因为
```java
  public class Pair<T> {
    private T first;
    private T last;
    public Pair() {
        // Compile error:
        first = new T();// 错误写法不能实例化
        last = new T();  //首先T都被翻译成Object了,first 都是Object类型,如果我们T想要的String 出现了冲突,为什么擦拭法不会冲突呢.一旦实例化,你在编译器看到Pair的时候,first就完成了实例化,T的类型是Object,后面擦拭转换的时候,类型出现了问题,first不是string,
    }
}

```


## Pair<Number>和Pair<Interger> 不是同一个类 使用extends 和supr的方法
## extends
+ 当我们定义这个方法以后static int add(Pair<Number> p)  我们不能传入Pair<Interger> ,但是Interger可以转换成Number,这样局限性就很大,
+ java提供了一个转换的方式
+ static int add<Pair<? extends Number>p> 这个方法一般用在传递参数上面.
+ Double类型也可以了,这样只要是Number的子类模板都可以使用,但是限制了String类型,Number不是String的父类.
+ extends 代表你只要是继承自Number的子类就行

## supr
+ static int add<Pair<? super Integer>p> 我么可以传入Integer父类模板,super 代表Integer的父类

## supr 和extends内部细节(PECS原则)
+ get方法和Set方法内部
  ```java
  public void setFirst(T first) {
        this.first = first;
    }
    public T getFirst() {
        return first;
    }
  ```
+ 两种代码格式 分别对应 extends 和supr
```java
public class Collections {
    // 把src的每个元素复制到dest中:
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        for (int i=0; i<src.size(); i++) {
            T t = src.get(i);
            dest.add(t);
        }
    }
}
```
```java
static void setSame(Pair<? super Integer> p, Integer n) {
        p.setFirst(n);
        p.setLast(n);
    }
```
+ supr和extends一般都用于形参
+ 在他们所在的方法中,我们经常会用到两个方法,一个是get 一个是set
+ get 的调用形式是 T t =src.get(i) //这个只能使用extends 为什么
+ 第一 extends 后面跟随父类,传入的是他的子类传入 Pair<Integer> 形参是Pair<number>
+ 因为形参所以T类型是number 而src是Interger,所以get你也是返回的Interger 这样转换没有问题,
+ 如果你使用了set方法,p.setFirst(n);还是同样的分析思路 n是number,而src是Integer,看到set内部,number转化成Integer 错误,


## 前看不懂不要紧 如何在适当场地使用supr 和extends(PECS原则)
+ PECS原则全称Producer Extends Consumer Super  ,Extends 是生产者,所以他只能get得到一个值,这个值是赋值过来的,他就增加了一个副本,这样不就是生产吗, set他重新设置了一个值,相当于把原来的值消灭了,这个就是消费者,














