## 他是基于lambda 表达式而来的
+ 什么使用使用方法引用
+ lambda 表达式他是实例化函数式接口,这个接口的函数我们发现有一个别的类,跟我们需要实现的代码相似我们就可以使用函数式接口,
+ 方法引用的使用要求: 要求接口中的抽象方法的形参列表和返回值和方法引用的方法的形参列表和返回值相同时,相当于一种借用

## 方法引用 对象:: 非静态方法
+ 我们需要创建一个对象才能引用非静态方法
```java
Consumer<String> consumer1 = str -> System.out.println(str);
        consumer1.accept("北京");
## lambda 表达式是去实现函数式接口的函数
## 而方法引用是 我们发现了一个方法,他跟函数接口的方法非常相似,而且方法引用中的方法他实现了我们想要的代码,所以我们直接获取借用这个方法
## 这就是lambda表达式跟方法引用的区别,前者是去实现,后者是借用


        PrintStream printSteams = System.out;
        Consumer<String> con2 = printSteams::println;
con2.accept("beijing");

```
##  方法引用 类:: 静态方法
+ Consumer<String> con2 =System.out::println;con2.accept("beijing"); //这种直接使用


## 构造器应用(了解一下,能看懂就行)
+ Supplier<EMployee> sup1 =() -> return new Employee(); //你想要利用lambda返回一个 Employee对象,就得在Supplier<EMployee(这就是你需要new的类型必须写上)>

+ 构造器引用写法
+ Supplier<Employee> sup2 =Employee::new ;   //调用Employee的构造器

+ 如果你有了一个参数以后 lambda 构造器引用写法: 
+ Function<Integer,Employee > func1 =id ->new Employee(id)  ,在Function接口中返回一个new对象,你必须写上Employee

+ 构成器引用写法:
+ Function<Integer,Employee> func2 =Employee::new ;