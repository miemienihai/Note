# 数据库恢复
## 数据库恢复和下一章并发的处理对象基本单位事务
+ 事务是将一行或者一段程序打包,这是恢复和并发处理最小单位
+ 如果事务正常执行 COMMIT提交修改数据到数据库, 如果事务中间的代码被打断 返回ROLLBACK,表示回滚到事务执行前的状态
### 事务的四个属性
+ 原子性(最小处理的单位)
+ 一致性: 是指 A和B对数据库的性别属性读取时,事务执行前 A和B读取到的内容是一样的,事务执行后 A和B读取到的内容是一样的,这样就是数据一致性,如果事务突然被打断,那么A读取到的是事务部分数据被写入的数据库,B读取到的就可能不同
+ 隔离性:两个事务之间不能干扰
+ 持续性: 

---
## 数据库存在几种错误
+ 事务内部故障
+ 系统故障



+ 介质故障
+ 计算机病毒
+ 数据库恢复是最后一道保障

###   事务内部故障
+ 这个一般是我们程序写在事务内部代码出现了问题,需要我们自己解决,数据库无法解决
+ 比如我们需要判断一个学生成绩是否不及格,我们程序员书写的代码是 我先拿你的成绩减去60 ,再去验证你是否小于0,这种思维一般是反人类思维,这样如果,事务在判断是否小于0之前被打断,那么学生的成绩就出现了负数,这显然是不可取的.

### 系统故障
+ 数据库系统突然崩溃,然后数据库系统自己会将所有不是正常执行完的事务全部结束

### 介质故障
+ 伤害最大,基本无解
+ 硬件损坏,原则是能恢复多少是多少

### 计算机病毒
+ 主要面临的数据库损坏问题.
  
---
## 数据库损坏后恢复的技术
+ 数据转储 (数据库的定时备份)
+ 登记日记功能(记录最近备份以后,执行的事务)

### 数据转储
+ 由于数据库内存消耗的问题,数据库不可能时时备份,所有只能定点备份,这样我们往往需要日记来恢复到最新的数据库状态
+ 静态转储: 备份期间事务不能执行,
+ 动态转储: 应为允许期间事务调用,所以这种备份的副本,有可能数据过时,所以我们需要日记来,更写过时的数据
+ 海量转储: 每次都存数据库全部数据
+ 增量转储: 存储上一次备份后更新的数据,

### 日记文件
+ 协助备份副本进行介质恢复
+ 动态转储必须建立日志文件
+ 为了保证数据库的日志文件正常工作需要保证以下两点
1. 日志的登录次序必须和事务执行顺序一样
2. 先写日记,再写数据库,这是因为,如果先写数据库,中途被打断,日记没有被记上,数据库出现了错误.

---
## 具体如何恢复数据库,恢复策略
### 事务故障恢复 (人为的程序的事务)
+ 反向扫描日志文件 ,查找写和改等对数据库数据操作的事务
+ 对事务实行逆操作
+ 重复上面的步骤

### 系统故障恢复 (类似断点操作)
+ 正向扫描日志文件,找出两种事务错误的问题,第一 没有完成的事务,第二故障发生前已经执行过的事务
+ 把第一种加入撤销队列
+ 第二种加入重做队列

### 介质故障恢复
+ 重装数据库,重新执行事务,降低损失
+ 装入最新的备份副本
+ 装入最新的日记副本,然后重做,尽可能的恢复
  
---
## 更新上面的恢复技术,具有检查点的恢复技术
+ 原来我们是找到数据库最新的备份,然后我们在使用日记重做事务,但是我们数据库在损坏之前,已经把这些事务的数据写入到了数据库,所以上面的步骤是一种重复费时的工作,检查点的思路是我们只要找出那些事务执行不正常,然后让这些事务正常执行就行了.
+ 重新开始文件: 主要记录检查点, 检查点记录自他建立那刻所有的事务,然后同时记录最新事务的地址
+ 日志文件: 记录事务

---
+ 检查点 恢复的步骤:
+ 先恢复到检查点所记录的那一刻,分为撤销队列和重做队列
+ 然后从检查点开始扫描,重做事务,直到完成,
+ 个人觉得检查点的优势在于他体量小,需要的内存不多.

---
## 数据库镜像系统,使用频率比较高的恢复技术
+ 镜像主要是对主数据库的拷贝
+ 同时应用软件可以访问主数据库,也可以访问镜像,这样就减轻了主数据库的压力

