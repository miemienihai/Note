## 基础概念
+ 函数依赖 : 我们有y=4x这个函数表达式,我们把y和x看做表的属性,可以,属性y的得出决定权在x手上,我们把这种类似函数表达式的关系叫做函数依赖,Y依赖于X
+ 部分函数依赖: (姓名,性别)推出学号,决定因素是姓名,跟性别没有太大关系,我们就叫做部分依赖于属性组的姓名
+ 完全函数依赖: (姓名) 推出学号,这个就是完全函数依赖,(姓名,选课号) 推出 你的任课老师的名字,这个也是完全函数依赖,完全代表缺一不可.
## 6.2.3 范式
+ 我们把范式分为几个层次,他们能够解决插入,删除,数据冗余的问题,不是说范式的等级越高越好
### 第一范式 1NF
+ 表中不能出现合并单元格的现象

### 第二范式 2NF
+ 第二范式是建立在第一范式上面的.
+ 定义:每一个非主属性完全依赖于任何一个候选码
+ 非主属性: 不是候选码的属性
+ 完全依赖于: (学号,性别) 推出 姓名, 我们可以看到决定姓名的是该学生的学号,跟他的性别没有决定关系,所以 认为这个码 的性别是多余的成分,因此这个就不是完全依赖, 而 (学号) -(姓名)  这种关系就是完全依赖

---
+ 2NF解决了一些问题:
+ 插入异常: 我们想要插入一个人到选课表R(学号,选课号,班主任名字)中 (学号,班主任名字)这些是我们对于学生的了解信息,但是这个学生刚来,没有选课,而按照我们上面的对于第二范式的解释中,我们把(学号,选课号)当做成学生的码,而插入表的是时候,你不知道选课号,所以你不能插入该学生,同时(学号)可以直接推出(班主任名字),跟(选课号)没有关系,我们就需要把这个表拆分成两组关系, 第一(学号,班主任名字) 第二 (学号,选课号),这样我们就可以插入学生信息了.
+ 删除异常 : 学生不选那个课程了,对于表R(学号,选课号,班主任名字),我们是把(学号,选课号)当做主码, 你既然要删除选课号,那么这一行都得删除,因为(学号,选课号)主码缺一不可,因此学号,班主任名字也都删除.
+ 修改复杂,存储信息也非常复杂,选课表R(学号,选课号,班主任名字)中,我们的学生每次选择一个课程,他的学号和班主任名字都要添加一遍,这样数据严重重复,同时删除也非常复杂.


### 第三范式 3NF
+ 第三范式建立在第二范式上面的
+ 他强调了不能出现函数传递的现象, x推出 y ,y推出z  ,y是代表非主属性,这里的y不是主属性是因为,你既然都是主属性(候选码),那么x主属性推出y主属性,这是肯定的,他不需要你指出,我们说这个y是非主属性,再从y推出z,这样才有意义,才能体现这个推导过程
+ 所以非主属性不依赖其他的非主属性.(解决了这个问题)
+ 关系表 R(学号，姓名，年龄，所在学院，学院地点，学院电话)
+ 存在(学号) → (所在学院) → (学院地点，学院电话)  所以不满足第三范式
+ 要想满足第三范式应修改为：R1(学号，姓名,年龄，所在学院) R2学院：(学院，地点，电话)
+ 我们把 学院当做另一个表的主码 就解决了在R表中,学院地点和电话依赖于非候选码的学院

#### BCNF
+ BCNF他是对于第三范式的完善,这个范式的级别很高了
+ 三条定义 p184
+ 第一 :就是 强调了第二范式的内容
+ 第二 :讲述 每个候选码依赖于不包含他的候选码, 表(身份证,学号,姓名,年龄) 身份证号和学号都是候选码 , 身份证号 依赖于 学号 (创新点)
+ 第三 : 没有依赖于非主属性的属性 (这个不就是第三范式中解决的问题)

#### 多值依赖 看书p185
#### 4NF 看书p188 主要是把非平凡的多值依赖变为平凡的多值依赖,解决表的多值依赖的问题
















## 6.3 数据依赖的公理系统
### 基本的Armstrong 公理论系统
+ R<U,F> U代表属性的集合,
+ F代表一组关系依赖,比如这个中有三个函数依赖, 身份证号 依赖 姓名  ,身份证号 -学号 等.
#### 第一点 自反律
+ Y 属性属于 X属性 也就是  Y(性格) ,x(姓名,性格),Y依赖于X,当然如此,你都得到了人的名字,你肯定得到了他的性格
  
#### 第二点 增广性
+ t[xz] =s[xz] ,t[x]代表元组t.x,是这一行的张三姓名.现在关系中有两个元组t和s,比如这两个元组的 (x,z) 都是为(张三,张三学号) ,把他们拆分以后当然也相同,t(张三) =s(张三) ,t(张三学号)=s(张三学号), 因为F中存在 Y依赖于X,所以给出X=张三,我们可以推出Y=男性,所以t[Y] =s[Y],因为t和s所在的行没变,因此t[YZ] =s[YZ],你当然可以得出 YZ函数依赖于XZ, XZ肯定依赖于XZ ,这里因为X可以推出Y,所以我们也就可以得到XZ -YZ;


#### 第三点 传递性
+ X推出Y Y推出Z ,身份证号推出他的学号 学号推出他的姓名, 那么肯定可以身份证号推出姓名, 也就是X推出Z


---

### 闭包 p191
#### 闭包的概念
+ R<U ,F> F所蕴含的函数依赖的全体就叫做F的闭包记作F+,你可以想象到这里我们谈论的对象是F,F代表的是表中的函数依赖(属性x依赖于属性y),所以这个闭包实际上代表的就是表的所有的函数依赖的一个集合,
+ 具体形式是 {x推出y,y推出z.....}
  
#### 属性集X的闭包
+ 这次我们谈论的对象是一个属性x,所以我们基于x推导y等函数依赖,通过Armstrong公理,我们推导出一系列关于x的函数依赖,我们把能通过x推导出来的所有属性集合到一起就叫做属性x的闭包
+ 形式 为{y,z,m......}  这个是由属性组合在一起的



----
### 最小依赖集 p193
+ 主要是第二和第三条定义不好理解,第二和第三这两条就是说,有的时候我们得出的函数依赖过多,有些是多余的信息,
+ 比如函数集F{x -y ,y -z ,x-z} x推出z明显是多余的信息,所以我们需要把它精简掉,这样的精简后的F就叫做最小依赖集
+ 同时我们这个精简出来的最小依赖集,他的属性闭包不能变化,因为我们只是精简,而不能影响他的表示.


#### 精简的算法也就是如何精简
+ 书上三步