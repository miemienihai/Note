+ 多线程的书本研究的有哪些
## 数据库
+ 我们在这一章讨论的数据库的主机是指 一台服务器上的并发
+ 事务是并发的基础单位

## 两个事务并发相互读取不合理造成的问题
### 丢失修改
+ 付款记录同时发生,所以我只付出了一分钱买了两份东西,这就是事务同时写入造成的相互涵盖的问题
  
### 不可重复读的问题
+ 读取的数据不一样: 事务A还在运行,他查询了今天是星期六,这个时候事务B修改了日历,导致我事务A再次读取到今天是星期天 这样事务A就无法理解了,报错了,事务A还在执行的时候,不应该运行事务B修改他自己需要的变量值.
+ 数据没有了:事务A发现没有星期这个变量了,事务B错误的给他删除了.事务A无法理解了
+ 数据变多了:事务A发现有两个变量星期1号,和星期二号,这个时候他又不理解了

### 读脏数据(临时数据)
+ 事务A签订了一份合同,但是他发现这份合同很多细节没有写上,但是这份合同已经让事务B给读取了,事务A因为合同不完善决定不再与B保持合同上的贸易,星期一事务B的市场部过来到事务A公司拿取货物,事务B遭到了拒绝,这个就是事务B读取了临时的数据
  
---
## 为了解决上述问题,我们提出了锁的概念
### 两把锁
+ 我们对变量读取的都需要加锁,这样你的数据就能得到保障,
+ 排他锁(写锁): 事务A给他的内部天气加了一个写锁,就不允许别的任何事务再给天气加上其他的锁.这个很好理解,你A在写天气的时候,你肯定不允许其他人写或者读
+ 共享锁(读锁) A给天气加了读锁,你A可以读,别人也可以读,两者不打扰,所以别人也可以在上面加上读锁,写锁肯定是被拒绝的.

### 如何加这两把锁,他们什么时候释放锁,细节问题-三级封锁协议(对上面的锁的要求给与清楚的实现)
#### 第一级
+ 加写锁的时候,只有事务执行完的时候,才会释放写锁, P
+ 缺点:不能保证重复读和脏数据,因为他没有对读锁给与了约束

#### 第二级
+ 在第一级上面,增加了咋读数据之前必须给加上读锁,读完就可以释放锁
+ 缺点:你没有约束读的时候加入写的锁

#### 第三级
+ 第二级上改变,只有植物结束的时候才会释放读锁
+ 上面的三个问题都得到了解决

___ 
## 活锁和死锁
+ 前面我们只定义了加锁的时机,但是我们没有说明给那些数据加锁,这样就容易造成死锁的现象,事务A他给M变量加锁,当他拿到变量N的锁的时候,他就会释放M锁,但是我们事务B刚好相反导致两者互相持有对方需要的锁,以至于两个互相锁死.

### 两种基础的预防死锁的方法
+ 一次封锁法:把事务A所用到所有数据全部加锁,第一我们通常无法衡量到底我们的事务需要给那些数据加锁,第二消耗大量资源
+ 顺序封锁法:指定一种事务封锁的顺序.但是这些都难预测,和浪费大量性能,所以我们认为死锁这种现象不太常见,同时我们只要解锁就行

### 所以我们需要有知道死锁的方法,同时在死锁的时候,只要撤销相关事务就行
+ 超时法: 一个事务等待超过预定时间,我们就认为发生了死锁,但是这种容易造成误杀
+ 等待图法: 我们在数据结构中,学过图出现循环的检查算法,因此我们只要认为出现回路,就有死锁的情况

---
## 抛开前面并发执行冲突的问题,如果我们两个事务同时执行,如果他们的执行顺序不对,那么你得出的结果也有问题
### 调度的可串行性来保证最终执行的顺序是正确的
+ 多个事务并发执行,与他们分开依次调用的结果相同,我们就称这种调度策略是可串行化的
+ 为什么提出串行化的概念,事务并发后的结果不正确,就是在于几个事务,他们对于同一变量,读取和写的顺序出现了问题,串行化它指出我们对于有的读写可以交换位置,让我们可以还原出与事务单独调用读写顺序一样,让我们来验证他们的并发顺序是否正确
+ 例如 :r1(A)W2(B)w1(A)r2(B)  我们通过交换 w2(B)和w1(A)顺序 -- 可以还原出他们单独调用的顺序 ,r1(A)w1(A)和w1(B)r2(B)
### 如果你交换了下面的操作,就出现了并发冲突,意味着其他的操作可以交换顺序,来还原出单独调用的顺序
#### 不同事务对于同一顺序调用顺序不可交换的情况
+ Ri(X)与Wj(X)  //先读后写不能换
+ Wi(x)与Wj(x)  //写写不能换
#### 同一事务的两个操作也是不能交换的
#### 串行化的细节
+ 有些可能满足串行化的调度的冲突,他们无法交换顺序,换出事务单独调用的顺序,但是他也是满足可串行化的.

## 遵守两端锁规则一定可以保证串行化
+ 一个事务 第一阶段是不断获取自己的数据的锁
+ 该事务再第二阶段 释放第一锁以后,不能再申请任何锁,这就是两段锁的规则
+ 只要你遵守他都是可串行化的.
+ 因为第一阶段不断要锁,所以有死锁的情况
  
---
## 锁的性能分析
### 锁的粒度
+ 第一种每次把整个数据库锁住
+ 第二种每次锁一个元组
+ 锁的对象不同,对于数据库性能要求也不同,所以我们需要加以分析
+ 第一种适合处理大量元组的事务,我一次把整个封了
+ 第二种适合处理少元组的事务

### 一次把整个数据库加锁,因此数据库的子类元组也默认需要加锁
+ 数据库加锁我们是显示的加锁 ,
+ 而数据库的子类是数据库系统帮忙完成的,这个是隐蔽的加锁
+ 我们需要知道这种隐蔽锁,所以我们创作了意向锁
### 意向锁
+ 当我们为一个节点加锁,那么他的下层也被加锁,这个时候他会往上层加一个意向锁,来标识
+ 具体看书


---
## 其他并发机制
+ 时间戳: 给每个事务加一个时间戳,如果发生冲突,就回滚到早期版本
+ 乐观控制法:如果发现该事务出现了冲突影响了串行性,拒绝他执行并回滚
+ 多版本控制法,通过维护数据的多个版本来控制

### 多版本控制法(现在很多数据库都在用,重要,书上笔记多,详细)
+ 写和读一个变量往往发生冲突,影响串行性,所以写一个数据,我就当做该数据单元的新版本,老版本就可以去读,这样读写不影响,非常高效并发
  